import * as ts from 'typescript';
import path from 'path';
import { outputFileSync, readFile, pathExists, removeSync } from 'fs-extra';
import { InFilesCache } from '@j.u.p.iter/in-files-cache';

import { TSCompiler } from './TSCompiler';


const SOURCE_CODE_FILE_NAME = 'fileName.ts';
const CACHE_FOLDER_NAME = 'cache'; 
const cacheFolderPath = path.resolve(__dirname, CACHE_FOLDER_NAME);
const sourceCodeFilePath = path.resolve(__dirname, '..', SOURCE_CODE_FILE_NAME);

const codeSnippet = `const func = (param: string): string => {
  return param;
}`;

const codeSnippetToArray = (codeSnippet) => codeSnippet.split('\n').map((lineOfCode) => lineOfCode.trim()); 

/**
 * Cache for the config is generated by the `@j.u.p.iter/in-files-cache` tool.
 *   We construct path to the cache file name, taking into account, how this tool
 *   works under the hood. In particularly, the name of the config will serve as the
 *   folder name for all files with cache for one concrete given config.
 *
 */
const generatePathToCachedFile = (fileContent) => {
  const inFilesCache = new InFilesCache(cacheFolderPath);
  const cacheFileName = inFilesCache.generateCacheFileName(fileContent, '.js');

  return path.resolve(
    __dirname, 
    CACHE_FOLDER_NAME, 
    SOURCE_CODE_FILE_NAME.replace('.ts', ''), 
    cacheFileName,
  );
};


describe('TSCompiler', () => {
  beforeEach(() => {
    removeSync(cacheFolderPath);
    removeSync(sourceCodeFilePath);
  });

  describe('for the virtual files', () => {
    it('compiles code and creates cache file on a disk with compiled version', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      await expect(pathExists(cacheFolderPath)).resolves.toBe(false);

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippet
      );

      await expect(pathExists(cacheFolderPath)).resolves.toBe(true);

      expect(codeSnippetToArray(compiledResult)).toEqual(
        codeSnippetToArray(`var func = function (param) {
            return param;
          };
        `)
      );

      const cachedFileContent = await readFile(generatePathToCachedFile(codeSnippet), 'utf8');
      expect(compiledResult).toEqual(cachedFileContent);
    });

    it('reads compiled code from cache instead of compiling file again', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      const compiledCodeInCache = 'var param = "hello";';

      outputFileSync(
        generatePathToCachedFile(codeSnippet),
        compiledCodeInCache,
        'utf8',
      );

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippet
      );

      expect(compiledResult).toBe(compiledCodeInCache);
    });
  });

  describe('for the real files', () => {
    it('compiles code and creates cache file on a disk with compiled version', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      outputFileSync(
        sourceCodeFilePath,
        codeSnippet,
        'utf8',
      );

      await expect(pathExists(cacheFolderPath)).resolves.toBe(false);

      const compiledResult = await tsCompiler.compile(SOURCE_CODE_FILE_NAME);

      await expect(pathExists(cacheFolderPath)).resolves.toBe(true);

      expect(codeSnippetToArray(compiledResult)).toEqual(
        codeSnippetToArray(`var func = function (param) {
            return param;
          };
        `)
      );

      const cachedFileContent = await readFile(generatePathToCachedFile(codeSnippet), 'utf8');
      expect(compiledResult).toEqual(cachedFileContent);
    });

    it('reads compiled code from cache instead of compiling file again', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      const compiledCodeInCache = 'var param = "hello";';

      outputFileSync(
        generatePathToCachedFile(codeSnippet),
        compiledCodeInCache,
        'utf8',
      );

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippet
      );

      expect(compiledResult).toBe(compiledCodeInCache);
    });
  });
})
