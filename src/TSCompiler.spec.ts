import * as ts from 'typescript';
import path from 'path';
import { outputFileSync, readFile, pathExists, removeSync } from 'fs-extra';
import { InFilesCache } from '@j.u.p.iter/in-files-cache';
import { InvalidPathError, TSTranspileError } from "@j.u.p.iter/custom-error";

import { TSCompiler } from '.';


const SOURCE_CODE_FILE_NAME = 'fileName.ts';
const CACHE_FOLDER_NAME = 'cache'; 
const cacheFolderPath = path.resolve(__dirname, CACHE_FOLDER_NAME);
const sourceCodeFilePath = path.resolve(__dirname, '..', SOURCE_CODE_FILE_NAME);

const codeSnippet = `const func = (param: string): string => {
  return param;
}`;

const invalidCodeSnippet = `func = param: string): string => {
  return param;
}`;

const codeSnippetThrowingError = `throw new Error('hello')`;

const codeSnippetToArray = (codeSnippet) => codeSnippet.split('\n').map((lineOfCode) => lineOfCode.trim()); 

/**
 * Cache for the config is generated by the `@j.u.p.iter/in-files-cache` tool.
 *   We construct path to the cache file name, taking into account, how this tool
 *   works under the hood. In particularly, the name of the config will serve as the
 *   folder name for all files with cache for one concrete given config.
 *
 */
const generatePathToCachedFile = (fileContent) => {
  const inFilesCache = new InFilesCache(cacheFolderPath);
  const cacheFileName = inFilesCache.generateCacheFileName(fileContent, '.js');

  return path.resolve(
    __dirname, 
    CACHE_FOLDER_NAME, 
    SOURCE_CODE_FILE_NAME.replace('.ts', ''), 
    cacheFileName,
  );
};


describe('TSCompiler', () => {
  beforeEach(() => {
    removeSync(cacheFolderPath);
    removeSync(sourceCodeFilePath);
  });

  describe('for the virtual files', () => {
    it('compiles code and creates cache file on a disk with compiled version', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      await expect(pathExists(cacheFolderPath)).resolves.toBe(false);

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippet
      );

      await expect(pathExists(cacheFolderPath)).resolves.toBe(true);

      // slice removes source map
      expect(codeSnippetToArray(compiledResult).slice(0, -1)).toEqual(
        codeSnippetToArray(`var func = function (param) {
            return param;
          };`)
      );

      const cachedFileContent = await readFile(generatePathToCachedFile(codeSnippet), 'utf8');
      expect(compiledResult).toEqual(cachedFileContent);
    });

    it('reads compiled code from cache instead of compiling file again', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      const compiledCodeInCache = 'var param = "hello";';

      outputFileSync(
        generatePathToCachedFile(codeSnippet),
        compiledCodeInCache,
        'utf8',
      );

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippet
      );

      expect(compiledResult).toBe(compiledCodeInCache);
    });

    it('throws an error if compiling code is invalid', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      const compiledResult = tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        invalidCodeSnippet
      );

      await expect(compiledResult).rejects.toThrow(TSTranspileError);
    });

    it('compiles code with inline source maps with inline sources', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippet
      );

      /**
       * The presence of dataURI in the sourceMappingURL tells us, 
       *   that the content of the source maps
       *   is inlined into the compiled file.
       *
       */

      expect(compiledResult.split('\n').pop()).toContain('//# sourceMappingURL=data:application/json;base64');
    });

    it('disables sourceMap option and enables inline source maps and inline sources', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {
          sourceMap: true,
          inlineSources: false,
          inlineSourceMap: false,
        }, 
      });

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippet
      );

      /**
       * The presence of dataURI in the sourceMappingURL tells us, 
       *   that the content of the source maps
       *   is inlined into the compiled file.
       *
       */
      expect(compiledResult.split('\n').pop()).toContain('//# sourceMappingURL=data:application/json;base64');
    });
  });

  describe('for the real files', () => {
    it('compiles code and creates cache file on a disk with compiled version', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      outputFileSync(
        sourceCodeFilePath,
        codeSnippet,
        'utf8',
      );

      await expect(pathExists(cacheFolderPath)).resolves.toBe(false);

      const compiledResult = await tsCompiler.compile(SOURCE_CODE_FILE_NAME);

      await expect(pathExists(cacheFolderPath)).resolves.toBe(true);

      // slice removes source map
      expect(codeSnippetToArray(compiledResult).slice(0, -1)).toEqual(
        codeSnippetToArray(`var func = function (param) {
            return param;
          };`)
      );

      const cachedFileContent = await readFile(generatePathToCachedFile(codeSnippet), 'utf8');
      expect(compiledResult).toEqual(cachedFileContent);
    });

    it('reads compiled code from cache instead of compiling file again', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      const compiledCodeInCache = 'var param = "hello";';

      /**
       * The original source file contains one type of content
       *   and the compiled file contains another content.
       *   This allows to detect, do we use cache or not 
       *   in this case.
       *
       */
      outputFileSync(
        sourceCodeFilePath,
        codeSnippet,
        'utf8',
      );

      outputFileSync(
        generatePathToCachedFile(codeSnippet),
        compiledCodeInCache,
        'utf8',
      );

      const compiledResult = await tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
      );

      expect(compiledResult).toBe(compiledCodeInCache);
    });

    it('throws an error, if there is no a file by provided path', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      /**
       * If we don't provide code snippet, compiler should find and read file internally.
       *   And if there is no such a file, it should throw an appropriate error.
       *
       */
      const compilingResult = tsCompiler.compile(SOURCE_CODE_FILE_NAME);

      await expect(compilingResult).rejects.toThrow(InvalidPathError);
      await expect(compilingResult).rejects.toThrow(`File ${sourceCodeFilePath} does not exist`);
    });

    it('throws an error if compiling code is invalid', async () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      const compiledResult = tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        invalidCodeSnippet
      );

      await expect(compiledResult).rejects.toThrow(TSTranspileError);
    });

    it('test source maps', () => {
      const tsCompiler = new TSCompiler({ 
        ts, 
        cacheFolderPath,
        compilerOptions: {}, 
      });

      tsCompiler.compile(
        SOURCE_CODE_FILE_NAME,
        codeSnippetThrowingError
      );
    });
  });
})
